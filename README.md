# A slightly sticky protobuf writer
Tacky is dead-simple, unopinionated protobuf serialiser. no trait magic or proc macros, just simple idiomatic codegen. Given a protobuf definition, this crate will generate a simple rust type with a builder-like API to write your message. 

# Example
for a simple message:
```protobuf
message Foo {
    int32 sum = 5;
    repeated string cities = 1;
    optional bytes blob = 2;
    map<string, int32> residents_per_city = 3;
}
```
the code is something like

```rust
pub struct FooWriter<'buf> {
    buffer: &'buf mut Vec<u8>
}

impl<'b> FooWriter<'b> {
    fn sum(&mut self, sum: i32) -> &mut Self {..}
    fn cities<T: AsRef<str>>(&mut self, cities: impl IntoIterator<Item = T>) -> &mut Self {..}
    fn blob<'opt>(&mut self, blob : impl Into<Option<&'opt [u8]>>) -> &mut Self {..}
    fn residents_per_city<'rep>(&mut self, impl IntoIterator<Item = (&'rep str, &'rep i32)>) -> &mut Self {..}
}   

fn useit(..) {
    let mut foo = ...;
    foo.sum(41)
       .cities(&["london", "paris", "stockholm"])
       .blob(None);
}
```

## what is this good for?
Most other rust protobuf implementations take the approach of translating the protobuf message schema into a type that maps exactly to it. this is fine if the types and models map 1-1 to their serialised schema, but when they do not, trouble ensues:

```rust
pub struct MyDataModel{
    unique: BTreeSet<Uuid>,
}
```
```protobuf
message PbData {
    repeated string unique = 1;
}
``` 
even though the working data set already exists, to serialise it with prost or quick-protobuf i would need to build a `Vec<String>` copying and allocating everything. Or....

```rust
fn writeit(a: MyDataModel) {
    let mut pb : PbDataWriter = ...;
    let mut uuid_buf = [0u8;36];
    for u in &a.unique {
        let uuid_str = u.to_hyphenated().encode_lower(&mut uuid_buf);
        pb.unique(uuid_str);
    }
}
```
in other words when you have a lot of data that doesnt fit nicely into the structs generated by other protobuf libs, this might do the trick.

## what about nested messages?
the problem with the above approach is that nested messages are length-delimited. that is, they require the length up-front, whereas using an incremental writer like Tacky, that might not be known when starting to write it. 

what we do here is a slight abuse of the LEB128 (varint) encoding. we allocate a fixed width length field up front, and set it to a temp length. once the message writer drops, it goes back to that place in the buffer and writes the correct length. this trick is also used by some wasm packers as wasm integers are varint encoded, and code sections need to be length delimited.